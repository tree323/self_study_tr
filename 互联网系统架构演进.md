# 互联网系统架构演进

## 目的

+ 掌握大型分布式系统架构方案&技术
+ 掌握系统架构设计思想
+ 掌握架构设计误区



网站一开始就是大型的吗?

我们应该一开始就设计一个大型的网站吗?



## 初生-简单的互联网应用架构

无名的小网站,访问量低,一台服务器满足需求.

典型的技术LAMP:Linux + Apache + MySQL + PHP

经典案例:淘宝 **一台服务器挂着三个应用**

![截屏2021-11-14 下午2.41.42](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141441294.png)



随着网站业务的发展,越来越多的用户访问,面临的问题:

+ 性能越来越差
+ 越来越多的数据导致**存储空间不足**



## 应用服务与数据服务分离

现在是三台服务器各自搭载各自的服务



![截屏2021-11-14 下午2.43.35](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141443889.png)



服务器对应不同的硬件需求

+ 应用服务器:需要更快更强大的CPU(处理大量的业务逻辑)
+ 数据库服务器:需要更快的硬盘和更大的内存(快速磁盘检索和数据缓存)
+ 文件服务器:需要更大的硬盘(存储大量用户上传的文件)

不同服务器承担不同的服务角色。并发处理能力以及数据存储空间都能得到大幅度的提升.



问题:

​	随着用户逐渐增多,网站再次面临挑战:

​		**数据库压力太大导致访问延迟**,进而影响整个网站的性能,用户体验受到影响.



考虑架构的核心:**当前阶段用什么技术最能解决问题?**



## 使用缓存改善性能

缓存: 

+ 本地缓存 (快 , 但是能够缓存的数据量小 , 征用内存)、
+ 远程分布式缓存(可以做到按需扩展-集群 , 慢,空间换时间)

常用缓存组件:memcache redis





![截屏2021-11-14 下午2.49.11](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141449867.png)

问题:

​	随着用户逐渐增多,单一应用服务器面临新的问题:

​		能够处理的请求连接有限,网站访问高峰期,应用服务器成为整个网站的瓶颈.

tomcat8 4000以上的并发

## 应用服务集群

使用应用服务器集群--改善网站的并发处理能力



![截屏2021-11-14 下午2.52.59](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141453896.png)

为什么不用更强的服务器? 依然有瓶颈

负载均衡的实现方式有哪些

负载均衡调度服务器需要具备高并发处理的能力

![截屏2021-11-14 下午2.55.05](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141455810.png)



问题:

​	使用缓存后,虽然大大减轻了数据库的读压力,但是面临新的问题:

​		有一部分读操作(缓存访问不命中,缓存过期)和全部的写操作要访问数据库,当用户规模达到一定规模后,数据库因为负载压力过高而成为整个系统的瓶颈.



## 数据库读写分离

采用数据库集群的方式,利用主从复制,写操作主库,读操作从库

![截屏2021-11-14 下午2.59.05](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141459826.png)

数据访问模块怎么做?

让下端数据存储的变化,不去影响上端应用程序的编写

![截屏2021-11-14 下午3.03.41](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141503365.png)

问题:

​	用户规模越来越大,发布地域越来越广,地域网络环境差别很大,

​	如何保证用户的访问体验,不至于因访问慢而流失用户?



## 反向代理和CDN(Content Delivery Network 内容分发网络)加速

找个代理商,将网站放在当地的CDN服务器,适用于静态资源,将静态资源提前缓存到各自服务器上

反向代理服务器也是将我们的静态资源缓存到反向代理服务器上.和CDN的区别,反向代理服务器部署在应用系统的最外层





![截屏2021-11-14 下午3.07.09](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141507874.png)

作用:加快用户访问响应速度,减轻后端服务器的压力



问题:

​	单文件服务器、单数据库服务器

​	存不下日益增长的数据



## 分布式文件系统和分布式数据库系统

![截屏2021-11-14 下午3.27.02](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141527747.png)

原来的主从数据库,存储的都是同一套数据,现在的分布式数据库服务器存储的就是分库分表之后的数据.![截屏2021-11-14 下午3.29.24](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141529789.png)



问题:

​	随着业务的发展,数据的存储需求和检索需求越来越复杂

​	存储的字段差异较大,骷髅表

​	复杂的文本检索



## 使用NoSQL 、 搜索引擎







![截屏2021-11-14 下午3.32.54](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141532803.png)

![截屏2021-11-14 下午3.33.24](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141533783.png)



问题:

​	网站越做越好,业务不断扩大,越来越复杂,

​	应用程序将变得无法**庞大**(单体应用),迭代周期越来越快,牵一发而动全身,怎么应对快速的业务发展需要?



## 业务拆分

如大型电商网站会将首页、商铺、订单、买家等拆分成不同的产品线,分归不同的团队负责,分为不同的应用,独立部署.通过链接、MQ、数据存储系统建立关联.

![截屏2021-11-14 下午3.37.13](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141537509.png)



问题:

​	业务规模不断增大,应用产分越来越小,越来越多

​	应用间的关系越来越复杂,应用中存在大量相同的业务操作

​	后端的数据库要被成千上万台应用服务器连接,数据库连接资源不足



## 分布式服务(服务化)



![截屏2021-11-14 下午3.42.12](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141542086.png)

**配置中心**

如何做服务化,如何做配置中心



服务化的两种架构方式:

+ SOA(Service Oriented Architecture)
+ 微服务 

![截屏2021-11-14 下午3.44.20](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141544647.png)

ESB:企业服务总线 中心点,会出现中心点瓶颈



问题:

​	数据挖掘 分析 推荐等业务需求,庞大系统的监控、问题分析等需求



## 大数据技术、监控、日志分析系统

不和应用系统直接发生关联



![截屏2021-11-14 下午3.47.21](https://raw.githubusercontent.com/tree323/picBed/main/img/202111141547966.png)



## 云原生应用技术架构

### 服务网格 - service mesh

#### 为什么我们需要服务网格

随着规模的增长，这种架构就显得力不从心了。像 Google、Netflix、Twitter 这样的公司面临着大规模流量的挑战，他们实现了一种高效的解决方案，也就是云原生应用的前身：应用层被拆分为多个服务（也叫作微服务），这个时候层就变成了一种拓扑结构。这样的系统需要一个通用的通信层，以一个“富客户端”包的形式存在，如 Twitter 的[ Finagle ](https://twitter.github.io/finagle/)、Netflix 的[ Hystrix ](https://github.com/Netflix/Hystrix)和 Google 的 Stubby。

一般来说，像 Finagle、Stubby 和 Hystrix 这样的包就是最初的 Service Mesh。云原生模型在原先的微服务模型中加入了两个额外的元素：容器（比如 Docker）和编排层（如 Kubernetes）。容器提供了资源隔离和依赖管理，编排层对底层的硬件进行抽象池化。

这三个组件让应用程序在云环境中具备了伸缩能力和处理局部故障的能力。但随着服务和实例的数量增长，编排层需要无时不刻地调度实例，请求在服务拓扑间穿梭的路线也变得异常复杂，再加上可以使用任意语言来开发不同的服务，所以之前那种“富客户端”包的方式就行不通了。

这种复杂性和迫切性催生了服务间通信层的出现，这个层既不会与应用程序的代码耦合，又能捕捉到底层环境高度动态的特点，它就是 Service Mesh。

#### 什么是服务网格

Service Mesh 是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，Service Mesh 保证请求可以在这些拓扑中可靠地穿梭。在实际应用当中，Service Mesh 通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但应用程序不需要知道它们的存在。



### 无服务化 - serverless



## 架构设计思想总结

+ 分而治之
+ 随网站所需灵活应对
+ 业务发展驱动技术发展,技术发展反哺业务
+ 软件系统的价值在于它能为用户提供什么价值,在于网站能做什么.而不在于它是怎么做的!



## 架构设计误区

+ 一味追随大公司的解决方案
+ 为了技术而技术
+ 企图用技术解决所有问题